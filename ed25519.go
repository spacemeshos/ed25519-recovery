// Copyright 2023 Spacemesh Authors. All rights reserved.

// Package ed25519-recovery implements a modified Ed25519 signature algorithm that allows
// for public key recovery. See https://github.com/spacemeshos/ed25519-recovery#readme.
package ed25519

import (
	"bytes"
	"crypto/ed25519"
	"crypto/sha512"
	"encoding/binary"
	"errors"
	"io"
	"strconv"

	"github.com/spacemeshos/ed25519-recovery/internal/edwards25519"
)

const (
	// PublicKeySize is the size, in bytes, of public keys as used in this package.
	PublicKeySize = ed25519.PublicKeySize
	// PrivateKeySize is the size, in bytes, of private keys as used in this package.
	PrivateKeySize = ed25519.PrivateKeySize
	// SignatureSize is the size, in bytes, of signatures generated and verified by this package.
	SignatureSize = ed25519.SignatureSize
	// SeedSize is the size, in bytes, of private key seeds. These are the private key representations used by RFC 8032.
	SeedSize = ed25519.SeedSize
)

// PublicKey is the type of Ed25519 public keys.
type PublicKey = ed25519.PublicKey

// PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer.
type PrivateKey = ed25519.PrivateKey

// GenerateKey generates a public/private key pair using entropy from rand.
// If rand is nil, crypto/rand.Reader will be used.
func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error) {
	return ed25519.GenerateKey(rand)
}

// NewKeyFromSeed calculates a private key from a seed. It will panic if
// len(seed) is not SeedSize. This function is provided for interoperability
// with RFC 8032. RFC 8032's private keys correspond to seeds in this
// package.
func NewKeyFromSeed(seed []byte) PrivateKey {
	return ed25519.NewKeyFromSeed(seed)
}

// ExtractPublicKey extracts the signer's public key given a message and its
// signature. It will panic if len(sig) is not [SignatureSize].
//
// Note: This function is not compatible with signatures created by
// "crypto/ed25519".Sign. Only signatures created by this package's Sign
// function can be used for public key recovery.
func ExtractPublicKey(message, sig []byte) (PublicKey, error) {
	// Outline the function body so that the returned PublicKey can be
	// stack-allocated.
	publicKey := make([]byte, PublicKeySize)
	err := extractPublicKey(publicKey, message, sig)
	return publicKey, err
}

func extractPublicKey(publicKey, message, sig []byte) error {
	if len(sig) != SignatureSize || sig[63]&224 != 0 {
		return errors.New("ed25519: bad signature format")
	}

	kh := sha512.New()
	kh.Write(sig[:32])
	// we remove the public key from the hash
	// kh.Write(privateKey[32:])
	kh.Write(message)
	hramDigest := make([]byte, 0, sha512.Size)
	hramDigest = kh.Sum(hramDigest)
	k, err := edwards25519.NewScalar().SetUniformBytes(hramDigest)
	if err != nil {
		return err
	}

	S, err := edwards25519.NewScalar().SetCanonicalBytes(sig[32:])
	if err != nil {
		return err
	}

	R, err := (&edwards25519.Point{}).SetBytes(sig[:32])
	if err != nil {
		return err
	}

	// [S]B = R + [k]A --> [k]A = -R + [S]B
	minusR := (&edwards25519.Point{}).Negate(R)
	KA := (&edwards25519.Point{}).Add(minusR, (&edwards25519.Point{}).ScalarBaseMult(S))

	// compute 1 / [k]
	kInv := InvertModL(k)

	// A = (1 / [k]) * [k]A
	A := (&edwards25519.Point{}).ScalarMult(kInv, KA)
	copy(publicKey, A.Bytes())
	return nil
}

// Sign signs the message with privateKey and returns a signature. It will
// panic if len(privateKey) is not [PrivateKeySize].
//
// The signature may be verified using this package's Verify function if the
// signer's public key is known.
//
// Note: This function is not compatible with "crypto/ed25519".Sign. The
// signatures generated by this function cannot be verified using
// "crypto/ed25519".Verify.
func Sign(privateKey PrivateKey, message []byte) []byte {
	// Outline the function body so that the returned signature can be
	// stack-allocated.
	signature := make([]byte, SignatureSize)
	sign(signature, privateKey, message)
	return signature
}

func sign(signature, privateKey, message []byte) {
	if l := len(privateKey); l != PrivateKeySize {
		panic("ed25519: bad private key length: " + strconv.Itoa(l))
	}
	seed := privateKey[:SeedSize]

	h := sha512.Sum512(seed)
	s, err := edwards25519.NewScalar().SetBytesWithClamping(h[:32])
	if err != nil {
		panic("ed25519: internal error: setting scalar failed")
	}
	prefix := h[32:]

	mh := sha512.New()
	mh.Write(prefix)
	mh.Write(message)
	messageDigest := make([]byte, 0, sha512.Size)
	messageDigest = mh.Sum(messageDigest)
	r, err := edwards25519.NewScalar().SetUniformBytes(messageDigest)
	if err != nil {
		panic("ed25519: internal error: setting scalar failed")
	}

	R := (&edwards25519.Point{}).ScalarBaseMult(r)

	kh := sha512.New()
	kh.Write(R.Bytes())
	// we remove the public key from the hash
	// kh.Write(publicKey)
	kh.Write(message)
	hramDigest := make([]byte, 0, sha512.Size)
	hramDigest = kh.Sum(hramDigest)
	k, err := edwards25519.NewScalar().SetUniformBytes(hramDigest)
	if err != nil {
		panic("ed25519: internal error: setting scalar failed")
	}

	S := edwards25519.NewScalar().MultiplyAdd(k, s, r)

	copy(signature[:32], R.Bytes())
	copy(signature[32:], S.Bytes())
}

// Verify reports whether sig is a valid signature of message by publicKey. It
// will panic if len(publicKey) is not [PublicKeySize].
//
// Note: This function is not compatible with "crypto/ed25519".Verify. Only
// signatures created by this package's Sign function can be verified using
// this function.
func Verify(publicKey PublicKey, message, sig []byte) bool {
	if l := len(publicKey); l != PublicKeySize {
		panic("ed25519: bad public key length: " + strconv.Itoa(l))
	}

	if len(sig) != SignatureSize || sig[63]&224 != 0 {
		return false
	}

	A, err := (&edwards25519.Point{}).SetBytes(publicKey)
	if err != nil {
		return false
	}

	kh := sha512.New()
	kh.Write(sig[:32])
	// we remove the public key from the hash
	// kh.Write(publicKey)
	kh.Write(message)
	hramDigest := make([]byte, 0, sha512.Size)
	hramDigest = kh.Sum(hramDigest)
	k, err := edwards25519.NewScalar().SetUniformBytes(hramDigest)
	if err != nil {
		panic("ed25519: internal error: setting scalar failed")
	}

	S, err := edwards25519.NewScalar().SetCanonicalBytes(sig[32:])
	if err != nil {
		return false
	}

	// [S]B = R + [k]A --> [k](-A) + [S]B = R
	minusA := (&edwards25519.Point{}).Negate(A)
	R := (&edwards25519.Point{}).VarTimeDoubleScalarBaseMult(k, minusA, S)

	return bytes.Equal(sig[:32], R.Bytes())
}
